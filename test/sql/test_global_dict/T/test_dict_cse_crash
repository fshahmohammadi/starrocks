-- name: test_dict_cse_crash
-- Test for crash when DictMappingExpr is in lambda's _common_sub_expr
-- Bug: expr_disable_open_rewrite uses children() instead of do_for_each_child()
-- which misses _common_sub_expr in LambdaFunction
-- Key: The repeated expression must involve the lambda argument to trigger CSE inside lambda

SET cbo_enable_low_cardinality_optimize = true;
SET enable_global_runtime_filter = true;
SET enable_join_runtime_filter_push_down = true;

CREATE TABLE t1 (
    id INT,
    str_col VARCHAR(100) NOT NULL,
    arr1 ARRAY<VARCHAR(10)>,
    arr2 ARRAY<VARCHAR(10)>
) ENGINE=OLAP DUPLICATE KEY(id) DISTRIBUTED BY HASH(id) BUCKETS 1 PROPERTIES ("replication_num" = "1");

CREATE TABLE t2 (id INT) ENGINE=OLAP DUPLICATE KEY(id) DISTRIBUTED BY HASH(id) BUCKETS 1 PROPERTIES ("replication_num" = "1");

INSERT INTO t1 VALUES (1, 'aaa', ['x','y'], ['a','b']), (2, 'bbb', ['x','y'], ['c','d']);
INSERT INTO t2 VALUES (1), (2);

SELECT SLEEP(3);
[UC] ANALYZE FULL TABLE t1;
function: wait_global_dict_ready('str_col', 't1')

-- Test 1: Lambda argument used with dict column in repeated expression
-- upper(concat(str_col, x)) is used twice - should extract as lambda common sub-expression
[UC]EXPLAIN VERBOSE
SELECT id, array_map(x -> concat(upper(concat(str_col, x)), upper(concat(str_col, x))), arr1) FROM t1;

[UC]SELECT id, array_map(x -> concat(upper(concat(str_col, x)), upper(concat(str_col, x))), arr1) FROM t1 ORDER BY id;

-- Test 2: Simpler pattern - concat(x, str_col) repeated with function
[UC]EXPLAIN VERBOSE
SELECT id, array_map(x -> length(concat(x, str_col)) + length(concat(x, str_col)), arr1) FROM t1;

[UC]SELECT id, array_map(x -> length(concat(x, str_col)) + length(concat(x, str_col)), arr1) FROM t1 ORDER BY id;

-- Test 3: With JOIN for runtime filter path
[UC]EXPLAIN VERBOSE
SELECT l.id, array_map(x -> concat(upper(concat(l.str_col, x)), upper(concat(l.str_col, x))), l.arr1)
FROM t1 l JOIN t2 r ON l.id = r.id;

[UC]SELECT l.id, array_map(x -> concat(upper(concat(l.str_col, x)), upper(concat(l.str_col, x))), l.arr1)
FROM t1 l JOIN t2 r ON l.id = r.id ORDER BY l.id;

-- Test 4: Nested lambda with repeated expression using lambda arg
[UC]EXPLAIN VERBOSE
SELECT id, array_map(x -> array_map(y -> length(concat(y, str_col)) + length(concat(y, str_col)), arr2), arr1) FROM t1;

[UC]SELECT id, array_map(x -> array_map(y -> length(concat(y, str_col)) + length(concat(y, str_col)), arr2), arr1) FROM t1 ORDER BY id;

-- Test 5: Nested lambda with JOIN
[UC]EXPLAIN VERBOSE
SELECT l.id, array_map(x -> array_map(y -> concat(upper(concat(y, l.str_col)), upper(concat(y, l.str_col))), l.arr2), l.arr1)
FROM t1 l JOIN t2 r ON l.id = r.id;

[UC]SELECT l.id, array_map(x -> array_map(y -> concat(upper(concat(y, l.str_col)), upper(concat(y, l.str_col))), l.arr2), l.arr1)
FROM t1 l JOIN t2 r ON l.id = r.id ORDER BY l.id;

-- Test 6: Multiple functions on dict column with lambda arg
[UC]EXPLAIN VERBOSE
SELECT id, array_map(x -> upper(concat(x, str_col)) || lower(concat(x, str_col)) || upper(concat(x, str_col)), arr1) FROM t1;

[UC]SELECT id, array_map(x -> upper(concat(x, str_col)) || lower(concat(x, str_col)) || upper(concat(x, str_col)), arr1) FROM t1 ORDER BY id;

DROP TABLE t1;
DROP TABLE t2;
